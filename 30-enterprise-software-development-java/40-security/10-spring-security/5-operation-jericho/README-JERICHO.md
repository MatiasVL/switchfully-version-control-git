# Operation Jericho (starting point: `5-operation-jericho`)

> This is the big one boys... this is where we say our prayers. First in, last out, MARINES!

Private! High command has assigned you with a special mission. They really liked the permission/feature-based authorization, 
but they want **token-based authentication** instead of HTTP basic authentication!

Are you up for the job? Great!

Let's move Private. Move, move, MOVE!  

## What's wrong with Basic Auth?

Throughout the previous codelabs you have set up a backend which allows for HTTP Basic authentication and permission/feature-based authorization.
- Our Permission/feature-based authorization works nicely!
- Our HTTP Basic authentication... does the job...

Although HTTP Basic authentication works rather well (given a secure TLS/HTTPS connection), it has certain limitations:
1. For each(!) request, the credentials are passed as clear text.
    - The clear text is actually not bad, since we should always send it over TLS/HTTPS.
    - But, it is send for every request, thus it gives a hacker the opportunity to steal the credentials. With other authentication strategies,
    a hacker only has one shot for this. The other requests will contain a session or token instead.
    - Furthermore, your browser will somehow have to keep those credentials in storage as long as you want to remain 'authenticated'. 
2. The back end can not force a log-out (because the concept of a log-in or log-out does not really exist in HTTP Basic Authentication) 

We will look into a different technique, a token-based technique called JSON Web Tokens (JWT)
- The English pronounce it as JOT, but we can act like normal people and just pronounce it as JeWeTe. :)

## JWT Introduction

JSON Web Tokens enables a secure way to transmit data between two parties in the form of a JSON object. It’s an open standard and it’s a popular mechanism for web authentication.

The JWT (JSON web token) is composed of:
1. A **header**
2. A **payload**
3. A **signature**
 
All three parts are individually encoded with Base64 and then concatenated by a dot (`header.payload.signature`):
- For example: 
    ```eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InRpbW15QGdtYWlsLmNvbSIsIm5iZiI6MTU0MjEyNDAxOSwiZXhwIjoxNTQyMTUyODE5LCJpYXQiOjE1NDIxMjQwMTl9.e9myNXvazgagxcrsgZ2k2FUC7gIMEW-sk4nFGIYS79A```

The JSON Web Token is generated by the backend upon a successful authentication attempt, and then given to the frontend. 
The frontend must then provide, for each protected request, the JSON Web Token to the backend in order to perform. 

### Part 1: Header
The header component of the JWT contains information about how the JWT signature should be computed. The header is a JSON object in the following format:
```
{
    "typ": "JWT",
    "alg": "HS256"
}
```

In this JSON, the value of the "typ" key specifies that the object is a JWT, and the value of the "alg" key specifies which hashing algorithm is being used to create the JWT signature component. 
In this example, the HMAC-SHA256 algorithm is used.

The Header is always (Base64) encoded, e.g. `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`

### Part 2: Payload
The payload component of the JWT is the data that's stored inside the JWT. These data are coded in **claims**, that is statements about an entity, 
typically the user. Claims are often very useful for enabling **authorization**.
```
{
    "userId": "b08f86af-35da-48f2-8fab-cef3904660bd"
	"email": "jimmy@jimmytimmy.com""
	"membershiplevel": "silver"
}
```

The Payload is always (Base64) encoded, e.g. `eyJlbWFpbCI6InRpbW15QGdtYWlsLmNvbSIsIm5iZiI6MTU0MjEyNDAxOSwiZXhwIjoxNTQyMTUyODE5LCJpYXQiOjE1NDIxMjQwMTl9`

### Part 3: Signature
The signature gets generated by combining the encoded header and payload together, then hashing the combined result by using a secret key that only server knows.
The signature itself then gets encoded as well, e.g. `e9myNXvazgagxcrsgZ2k2FUC7gIMEW-sk4nFGIYS79A`

### All 3 parts combined into a JSON Web Token
Now that we have created all three components, we can create the JWT. Remembering the `header.payload.signature` structure of the JWT, 
we simply need to combine 3 components (header, payload and signature), with periods (`.`).

**JWT**:
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InRpbW15QGdtYWlsLmNvbSIsIm5iZiI6MTU0MjEyNDAxOSwiZXhwIjoxNTQyMTUyODE5LCJpYXQiOjE1NDIxMjQwMTl9.e9myNXvazgagxcrsgZ2k2FUC7gIMEW-sk4nFGIYS79A
```

### Verifying the JWT

Remember how a JWT contains a digital signature that gets generated by the backend by combining the header and the payload? 
For generating a valid signature, a secret key that only the backend (server) knows is used. This means several things:
- Should a malicious user change the header or the payload, the signature is no longer valid.
- If a malicious user changes either header or payload, it needs to create a new, valid signature. But for this the secret key is required, which only the backend has.
- The backend, based on the signature, can quickly validate if a received JWT is a valid token, and one that it created itself. 

So, if malicious users try to modify the values in the payload, they have to recreate the signature and for that purpose, 
they need the secret key which the only server has. 

At the server side, we can easily verify and validate a provided JWT by comparing the signature of the provided JWT 
with a newly computed signature - using the secret key - created from the header and payload part of the provided JWT.

Using JWT, the backend/server can easily verify the **integrity** of the JWT by comparing the digital signatures.

Furthermore, upon creating a JWT, an expiration date (e.g. 1 hour) can be set as part of the payload. Upon receiving a JWT, 
the backend can quickly validate if the received token is already expired

## Implementing JWT

